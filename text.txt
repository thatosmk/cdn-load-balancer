
    ApplicationContainer app[num_servers];
    ApplicationContainer client4;
Simulator::Run ();
Simulator::Destroy ();
    // select destination node
    for(unsigned int i=0; i<servers.size(); i++)
    {
        // get network server IP InterfaceContainers
        PacketSinkHelper packetSinkHelper("ns3::TcpSocketFactory",InetSocketAddress(servers.at(i).getIPContainer().GetAddress(i+1),8080));


        // install the packet sinker
        ApplicationContainer sinkApp4 = packetSinkHelper.Install(servers.at(i).getNodes().Get(i+1));
        sinkApp4.Start(Seconds(0.0));
        sinkApp4.Stop(Seconds(20.0));


        // select client node
        OnOffHelper onOff = OnOffHelper("ns3::TcpSocketFactory", InetSocketAddress(servers.at(i).getIPContainer().GetAddress(2), 8080));
        onOff.SetAttribute ("OnTime", StringValue("ns3::ConstantRandomVariable[Constant=50]"));
        onOff.SetAttribute ("OffTime", StringValue("ns3::ConstantRandomVariable[Constant=0]"));
        onOff.SetAttribute ("DataRate", DataRateValue(DataRate ("10Mbps")));
        onOff.SetAttribute ("PacketSize", UintegerValue(768));
        ///onOff.AddTraceSource ("Tx", MakeCallback(&IntTrace));

        NodeContainer  onoff;
        onoff.Add(servers.at(i).getNodes().Get(2));
        app[i] = onOff.Install(onoff);

        CsmaHelper csma;

        csma.EnablePcap("test_pcaps/pattern1_n4_to_cluster2", servers.at(i).getNetDev().Get(i+1), true);

        // select destination switch
        client4 = onOff.Install(servers.at(i).getNodes().Get(3));
        client4.Start(Seconds (2.0 ));
        client4.Stop(Seconds (20.0));
    }

    for (unsigned int i=0;i<servers.size();i++){
        app[i].Start (Seconds (1.0));
        app[i].Stop (Seconds (20.0));
    }

    //p2p1.EnablePcapAll("pcaps/pattern1_p2p1");

	Ipv4GlobalRoutingHelper::PopulateRoutingTables ();


    Ptr<FlowMonitor> flowMonitor;
    FlowMonitorHelper flowHelper;
    flowMonitor = flowHelper.InstallAll();

    Simulator::Stop (Seconds(20.0));

    
	Simulator::Run ();

    uint32_t txPacketsum = 0;
    uint32_t rxPacketsum = 0;
    uint32_t DropPacketsum = 0;
    uint32_t LostPacketsum = 0;
    double Delaysum = 0; 
    //Print per flow statistics
    flowMonitor->CheckForLostPackets ();
    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowHelper.GetClassifier ());

    // write to file
    string filename = "test_pcaps/load.txt";
    ofstream out(filename.c_str(), ios_base::app);

    std::map< FlowId, FlowMonitor::FlowStats > stats = flowMonitor->GetFlowStats ();   
    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator iter = stats.begin (); iter !=
    stats.end (); ++iter)
    {
        txPacketsum += iter->second.txPackets;
        rxPacketsum += iter->second.rxPackets;
        LostPacketsum += iter->second.lostPackets;
        DropPacketsum += iter->second.packetsDropped.size();
        Delaysum += iter->second.delaySum.GetSeconds(); 

        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (iter->first);

        out << iter->first << "," << iter->second.txPackets << endl;
        NS_LOG_UNCOND("Flow ID: " << iter->first << " Src Addr " << t.sourceAddress << " Dst Addr " << t.destinationAddress);
        NS_LOG_UNCOND("Tx Packets = " << iter->second.txPackets);
        NS_LOG_UNCOND("Rx Packets = " << iter->second.rxPackets);
        NS_LOG_UNCOND("Throughput="<<iter->second.rxBytes * 8.0/(iter->second.timeLastRxPacket.GetSeconds()-iter->second.timeFirstTxPacket.GetSeconds())/1024<<"Kbps");
    }

    out.close();

    std::cout << "\n";
    std::cout << "\n";
    std::cout << "  All Tx Packets: " << txPacketsum << "\n";
    std::cout << "  All Rx Packets: " << rxPacketsum << "\n";
    std::cout << "  All Delay: " << Delaysum / txPacketsum << "\n";
    std::cout << "  All Lost Packets: " << LostPacketsum << "\n";
    std::cout << "  All Drop Packets: " << DropPacketsum << "\n";
    std::cout << "  Packets Delivery Ratio: " << ((rxPacketsum * 100) /txPacketsum) << "%" << "\n";
    std::cout << "  Packets Lost Ratio: " << ((LostPacketsum * 100) /txPacketsum) << "%" << "\n";

      
    flowMonitor->CheckForLostPackets();
    flowMonitor->SerializeToXmlFile("test_pcaps/NameOfFile.xml", true, true);
    // write output to file
    // install load balancer on the network
    /*
    vector<double> dummy_load;

    for(unsigned int i=0; i<100; i++)
    {
        double d_load = ((double)rand() / (RAND_MAX));
        dummy_load.push_back(d_load); 
    }



    vector<double> loads;
    string filename = "./test_pcaps/data.csv";
    ifstream in(filename.c_str());
    string line,  comma, data;

    if(!in) { cerr << "File could not be opened!" << endl; }

    while(getline(in, line))
    {
        istringstream iss(line); 

        while(!iss.eof())
        {
            iss >>  data >> ws; 
            double l = atof(data.c_str())/90000000;
            loads.push_back(l);
        }
    }

    int time = 0;
    for(int server: lb.connect(cdn, loads))
    {
        cout << "time: "<<time++<<" need " << server << " servers" << endl; 
    }
    */
